
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: dev_nb/data.ipynb

from pathlib import Path
from exp.nb_01 import ListContainer,listify,DataLoader
import os
import PIL
import mimetypes
import torch
from functools import partial
import pandas as pd
from torch import nn

path = Path('C:/Users/iamab/Downloads/celeb')

##Creating new functionalities in a given library
Path.ls = lambda x: list(x.iterdir())

image_extensions = [i[1:] for i,j in mimetypes.types_map.items() if j.startswith('image')]

image_extensions = set(image_extensions)

def get_files(path, extensions = image_extensions, recurse = False):
    if recurse:
        res = []
        for p,d,f in os.walk(path):
            if f:
                if f[0].split('.')[-1] in extensions: res += get_files(Path(p),recurse = False)
        return res
    else:
        return [path/i for i in os.scandir(path)]

def compose(x,funcs,**kwargs):
    for f in sorted(listify(funcs), key = lambda o: getattr(o, '_order', 0)): x = f(x, **kwargs)
    return x


class ItemList(ListContainer):
    def __init__(self,items,tfms = None):
        super().__init__(items)
        self.tfms = tfms
    def new(self,items, cls = None):
        if cls is None: cls = self.__class__
        return cls(items,self.tfms)
    def get(self,i): return i
    def _get(self,i): return compose(self.get(i), self.tfms)
    def __getitem__(self,i):
        res = super().__getitem__(i)
        if isinstance(res,list): return [self._get(j) for j in res]
        return self._get(res)

    def index(self,i): return self.items[i]

class ImageList(ItemList):
    @classmethod
    def from_files(cls,path,extensions = None,recurse = None, **kwargs):
        return cls(get_files(path,extensions,recurse),**kwargs)

    def get(self,i): return PIL.Image.open(i)

def func(df,x):
    return [1 if i == 1 else 0 for i in x[df.columns[1:]]]

class LabeledList():
    def __init__(self,df,x,y):
        self.df = df
        self.x,self.y = x,y
#         self.func = f
#         self.labels = []

    def __getitem__(self,i): return self.x[i], self.y[i]

    def get_labels(self,i,label):
        if isinstance(i,int): return [self.df.iloc[i][label]]
        return list(self.df.iloc[i][label])

    def __len__(self): return len(self.x)

    def __repr__(self): return f'{self.__class__.__name__}\nx: {self.x} \ny: {self.y}'

    @classmethod
    def label_by_df(cls,items,csv_path,label):
#         f = list(df1.iloc[1:3].apply(lambda x: [1 if i == 1 else 0 for i in x[df1.columns[1:]]], axis = 1))[0]
#         df = pd.read_csv(csv_path)
        df = pd.read_csv(csv_path)
        y = (list(df.iloc[range(len(items))][label]))

        return cls(df,items,y)

    @classmethod
    def label_none(cls,items,csv_path):
        df = pd.read_csv(csv_path)
        return cls(df,items,items)

class Transform(): _order = 0

def into_rgb(x): return x.convert('RGB')

class ResizeFixed(Transform):
    _order=10
    def __init__(self,size):
        if isinstance(size,int): size=(size,size)
        self.size = size

    def __call__(self, item): return item.resize(self.size, PIL.Image.BILINEAR)

def to_byte_tensor(item):
    res = torch.ByteTensor(torch.ByteStorage.from_buffer(item.tobytes()))
    w,h = item.size
    return res.view(h,w,-1).permute(2,0,1)
to_byte_tensor._order=20

def to_float_tensor(item): return item.float().div_(255.)
to_float_tensor._order=30

tfms = [into_rgb, ResizeFixed(128), to_byte_tensor, to_float_tensor]